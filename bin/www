#!/usr/bin/env node

require('../config/globals');

// set up clustering
const cluster = require('cluster');
const COLORS = ['white', 'blue', 'cyan', 'green', 'yellow', 'red', 'magenta'];
let healthy = false;

/* ==============================
 * Master Process:
 *      1: Authenticates database
 *      2: forks workers based on configured threads
 *      3: listens for shutdown events to kill workers
 *      4: automatically self-terminates if clusters exit before any are listening
 *      5: tracks number of listening workers, attempts to revive workers that crash
 * ============================== */

if(cluster.isMaster) {

  const workers = {};
  let database = require('../config/database');

  // make sure the database is working before spawning children
  return database.authenticate()
  .then(() => {
    console.log(colors.gray(`${database.config.database} authenticated`))

    for(let i = 0; i < CONFIG.process.threads; i++) {
      let thisChild = cluster.fork();
    }

    var connectedWorkers = 0

    cluster.on('listening', (worker, code, signal) => { 
      helathy = true;
      if(worker.id in workers) return; // the cluster is already listening
      workers[worker.id] = true;

      connectedWorkers++;
      if(process.stdout.isTTY) process.stdout.write(colors[COLORS[worker.id % 7]]('â– '))
      if(connectedWorkers >= CONFIG.process.threads) {
        if(process.stdout.isTTY) process.stdout.cursorTo(0)
        console.log(colors.gray(`${connectedWorkers} workers listening`))
      }
    });

    cluster.on('message', (worker, message, handle) => {
      console.log(colors[COLORS[worker.id % 7]](`${worker.process.pid}: ${message}`))
      if(message == 'shutdown') worker.kill();

    })

    cluster.on('exit', (worker, code, signal) => {
      if(!healthy) return process.exit(1);
      delete workers[worker];
      connectedWorkers--;
      if(worker.exitedAfterDisconnect || code == 0) return console.log(`${connectedWorkers} workers listening`);

      console.log(colors[COLORS[worker.id % 7]](`worker ${worker.process.pid} died; reconnecting...`))
      cluster.fork();
    })

    cluster.on('disconnect', (worker, code, signal) => {
      console.log(colors[COLORS[worker.id % 7]](`worker ${worker.process.pid} disconnected`))
    });

  })
  .catch(err => {
    console.error(err)
    process.exit(1)
  })

/* ==============================
 * Worker Process:
 *      1: syncs to database
 *      2: once synced, starts listening on configured port
 *      3: when the server encounters an error, the worker kills itself
 * ============================== */

} else {

  var port = Number(process.env.PORT) || '3000';
  var app = require('../app');
  app.set('port', port);

  colors.process = colors[COLORS[cluster.worker.id % COLORS.length]]

  var debug = require('debug')('dmhelper:server');
  var http = require('http');
  var db = require('../models');

  var server = http.createServer(app);
  const { attachWebSockets } = require('../config/sockets');

  db._connection.on('error', err => {
    console.error(colors.process(`Worker ${process.pid} could not connect to the database:`, err.stack))
    process.exit(1);
  })

  // wait until the process is connected to the database before listening to any requests
  db._connection.on('synced', () => {
    // console.log(`Worker ${process.pid} is connected`)

    server.listen(port);

    server.on('listening', () => {
      // child is listening

      // set up websocket server using this server
      // problem: the server instance is only available from this file, so the websocket setup needs to be here as well
      // TODO: abstract away server setup and construction, and the underlaying configuration code for 
      //        setting up websockets to utilize the same session information as regular HTTP requests
    });

    server.on('error', err => {
      console.error(err.message)
      return process.exit(1);
    });

    // attaches GraphQL / Apollo websocket interface
    attachWebSockets(server);


  });

}
