scalar DateTime

# ==============================
# Queries
# ==============================

type Query {
	session: Session
	user(slug: String): [User]

	# Calendar: query the calendar based on optional year, motnh, day arguments OR a start and end timestamp
	calendar(campaign: ID! year: Int, month: Int, day: Int, start: Int, end: Int): Calendar
	character(slug: String, campaign: ID, user: ID, search: String): [Character]
	campaign(slug: String, search: String, owner: ID): [Campaign]
	item(slug: String, character: ID, search: String): ItemCollection
	journal(slug: String, character: ID, search: String): [Journal]

	lore(slug: String, character: ID, search: String): [Lore]
	knowledge(slug: String, character: ID, search: String): [LoreGroups]
}

# ==============================
# Mutations
# ==============================

type Mutation {
	user(user: UserInput, id: ID): User # create / update user account
	campaign(campaign: CampaignInput, id: ID, destroy: Boolean): Campaign # create / update campaign
	character(character: CharacterInput, id: ID, destroy: Boolean): Character # create / update character
	session(session: SessionInput, destroy: Boolean): Session # log in
}

# ==============================
# Subscriptions
# ==============================

type Subscription {
	session: Session
	test: [Character]
}

interface Node {
	id: ID!
}

type Session {
	jwt: String #jwt generated when the session is created, persistent login
	user: User
	character: Character
	campaign: Campaign
}

input SessionInput {
	alias: String! # username or email
	password: String! # unhashed password
}

# ==============================
# Types
# ==============================

type Image implements Node {
	id: ID!
	path: String
	node: Node
}

type User implements Node {
	id: ID!
	character: Character
	characters: [Character!]!
	email: String
	url: String
	name: String
}

input UserInput {
	id: ID
	name: String
	email: String
	password: String
	password_confirm: String
}

type Character implements Node {
	id: ID!
	name: String
	campaign: Campaign
	images: [Image!]!
	items: ItemCollection
	journal: [Journal!]!
	knowledge: [Lore!]!
	lore: [Lore!]!
	url: String
}

input CharacterInput {
	id: ID
	name: String
}

type Item implements Node {
	id: ID!
	name: String
	value: Float
	weight: Float
	quantity: Int
	total_value: Float
	total_weight: Float
	total_quantity: Int
	lore: [Lore!]!
	items: ItemCollection
	url: String
	owner: Character
}

# Meta item information
type ItemCollection {
	items: [Item!]!
	total_quantity: Int
	total_weight: Float
	total_value: Float
}

type Lore implements Node {
	id: ID!
	topic_type: String
	topic: Node
	owner: User
	content: String
	url: String
}

type LoreGroups {
	topic_name: String
	topics: [LoreList]
}

type LoreList {
	topic: Node
	lore: [Lore]
}

type Journal implements Node {
	id: ID!
	title: String
	content: String
	url: String
}

type Campaign implements Node {
	id: ID!
	name: String
	system: System
	url: String
	slug: String # The slug component of the url
	privacy_level: String

	# Associations
	owner: User
	characters: [Character!]!
	lore: [Lore!]!
	quests: [Quest!]!
	calendar: Calendar

	# Meta information
	total_quests: Int
	total_characters: Int
	total_users: Int # may require tricky aggregations
	total_lore: Int
	total_quests: Int
	total_events: Int
}

input CampaignInput {
	id: ID
	slug: String
	name: String!
	system: String
	privacy_level: String
}

# ==============================
# Calendar Types
# 	- Calendar
#	- CalendarConnection
#	- Event
# ==============================

type Calendar {
	year_length: Int
	weekdays: [String]
	months: [String]
	events: EventConnection
}

type EventConnection {
	years: [Year!]!
}

type Year {
	year: Int!
	months: [Month!]!

}

type Month {
	name: String
	weeks: [Week!]!
}

type Week {
	days: [Day]!
}

type Day {
	is_present: Boolean
	events: [Event]
}

type Event {
	timestamp: Int
	time: String
	name: String

}

enum QuestStatus {
	complete
	active
	failed
}

type Quest implements Node {
	id: ID!
	name: String
	url: String
	description: String
	status: QuestStatus

	subquests: [Quest!]!
	comments: CommentSection
	# comments: [Comment!]!
}

type Comment implements Node {
	id: ID!
	createdAt: DateTime
	body: String
	archived: Boolean
	character: Character
	children: [Comment!]!
}

type CommentSection {
	children: [Comment!]!
	total: Int
}

type System {
	key: String
	name: String
	publisher: String
	year: Int
}
